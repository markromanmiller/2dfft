<title>2D Fast Fourier Transform Live Demo</title>
<meta charset="UTF-8">
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='2D fast Fourier transform(2DFFT) live demo using WebGL2.0.'>
<!-- <script src='https://cdn.jsdelivr.net/npm/vue/dist/vue.js'></script> -->
<script src='vue.min.js'></script>
<!-- <script src='three.min.js'></script> -->
<script src='three.js'></script>

<div class='app'>
    <h1>2D Fast Fourier Transform Demo</h1>
    <h2>Forward</h2>
    <h3>Original Image</h3>
    image URL: 
    <input v-model='imageURL'> 
    <button v-on:click='loadImage'>Update</button><br>
    <canvas id='cv0'></canvas>
    <canvas id='cv1'></canvas>
    <h2>Backward</h2>
    <canvas id='cv2'></canvas>
    <canvas id='cv3'></canvas>
</div>


<script type="x-shader/x-vertex" id="vs" >
    #version 300 es
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
</script>

<!-- fscv0 {{{ -->
<script type='x-shader/x-fragment' id='fscv0'>
    #version 300 es
    precision highp float;
    
    uniform vec2 d;
    uniform sampler2D ta;
    
    out vec4 fragColor;
    
    void main() {
        vec4 c = texture(ta, gl_FragCoord.xy*d);
        fragColor = vec4((c.r + c.g + c.b)/3.0);
    }
</script>
<!-- }}} -->

<!-- fscv1 {{{ -->
<script type='x-shader/x-fragment' id='fscv1'>
    #version 300 es
    precision highp float;
    precision mediump int;
    
    uniform int N;
    uniform vec2 d;
    uniform sampler2D ta;
    
    out vec4 fragColor;
    
    void main() {
        uint n = uint(N);
        uvec2 pi = uvec2(gl_FragCoord.xy);
        pi = (pi + (n >> 1))%n;
        vec2 pf = vec2(pi) + 0.5;
        float F = log(length(texture(ta, pf*d).rg*float(N)))/8.0; // TODO 8 is magick number
        fragColor = vec4(F);
    }
</script>
<!-- }}} -->

<!-- fscv2 {{{ -->
<script type='x-shader/x-fragment' id='fscv2'>
    #version 300 es
    precision highp float;
    precision mediump int;
    
    uniform int N;
    uniform vec2 d;
    uniform sampler2D ta;
    
    out vec4 fragColor;
    
    void main() {
        uint n = uint(N);
        uvec2 pi = uvec2(gl_FragCoord.xy);
        pi = (pi + (n >> 1))%n;
        vec2 pf = vec2(pi) + 0.5;
        float F = log(length(texture(ta, pf*d).rg*float(N)))/8.0; // TODO 8 is magick number
        fragColor = vec4(F);
    }
</script>
<!-- }}} -->

<!-- fscv3 {{{ -->
<script type='x-shader/x-fragment' id='fscv3'>
    #version 300 es
    precision highp float;
    precision mediump int;
    
    uniform int N;
    uniform vec2 d;
    uniform sampler2D ta;
    
    out vec4 fragColor;
    
    void main() {
        fragColor = vec4(texture(ta, gl_FragCoord.xy*d).x);
    }
</script>
<!-- }}} -->

<!-- fs0 {{{ -->
<script type='x-shader/x-fragment' id='fs0'>
    #version 300 es
    precision highp float;
    precision mediump int;
    
    uniform int N;
    uniform vec2 d;
    uniform sampler2D ta, tb;
    
    out vec4 fragColor;

    uvec2 reverse(uvec2 n) {
        uvec2 res = uvec2(0u);
        for(uint i=1u;i<uint(N);i<<=1u){
            res <<= 1u;
            res |= n & 1u;
            n >>= 1u;
        }
        return res;
    }
    
    void main() {
        uvec2 pi = uvec2(gl_FragCoord.xy);
        pi = reverse(pi);
        vec2 pf = (vec2(pi) + 0.5)*d;
        vec4 c = texture(ta, pf);
        float gray = (c.r + c.g + c.b)/3.0;
        fragColor = vec4(gray/float(N), 0.0, 0.0, 0.0);
    }
</script>
<!-- }}} -->

<!-- fs1 {{{ -->
<script type='x-shader/x-fragment' id='fs1'>
    #version 300 es
    precision highp float;
    precision mediump int;
    
    uniform int N;
    uniform int itr;
    uniform vec2 d;
    uniform sampler2D ta;
    
    out vec4 fragColor;

    vec2 mul(vec2 a, vec2 b) {
        return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
    }

    vec2 expi(uint n) {
        float y  = -2.0*acos(-1.0)/float(itr)*float(n);
        return vec2(cos(y), sin(y));
    }
    
    void main() {
        uint n = uint(N);
        uint m = uint(itr);
        uvec2 pi = uvec2(gl_FragCoord.xy);
        uvec2 pim = pi&((m>>1)-1u);
        uvec2 pio = pi&~(m-1u)+pim;
    
        vec2 v0 = texture(ta, (vec2(pio+uvec2(0u,   0u  ))+0.5)*d).xy;
        vec2 v1 = texture(ta, (vec2(pio+uvec2(m>>1, 0u  ))+0.5)*d).xy;
        vec2 v2 = texture(ta, (vec2(pio+uvec2(0u,   m>>1))+0.5)*d).xy;
        vec2 v3 = texture(ta, (vec2(pio+uvec2(m>>1, m>>1))+0.5)*d).xy;
    
        //v0 = mul(v0, expi((0u       )%m));
        v1 = mul(v1, expi((pi.x     )&(m-1u)));
        v2 = mul(v2, expi((pi.y     )&(m-1u)));
        v3 = mul(v3, expi((pi.x+pi.y)&(m-1u)));

        vec2 res = v0+v1+v2+v3;
        fragColor = vec4(res, 0.0, 0.0);
    }
</script>
<!-- }}} -->

<!-- fs2 {{{ -->
<script type='x-shader/x-fragment' id='fs2'>
    #version 300 es
    precision highp float;
    precision mediump int;
    
    uniform int N;
    uniform int itr;
    uniform vec2 d;
    uniform sampler2D ta, tb;
    
    out vec4 fragColor;

    uvec2 reverse(uvec2 n) {
        uvec2 res = uvec2(0u);
        for(uint i=1u;i<uint(N);i<<=1u){
            res <<= 1u;
            res |= n & 1u;
            n >>= 1u;
        }
        return res;
    }
    
    void main() {
        uvec2 pi = uvec2(gl_FragCoord.xy);
        pi = reverse(pi);
        vec2 pf = (vec2(pi) + 0.5)*d;
        fragColor = texture(ta, pf)/float(N);
    }
</script>
<!-- }}} -->

<!-- fs3 {{{ -->
<script type='x-shader/x-fragment' id='fs3'>
    #version 300 es
    precision highp float;
    precision mediump int;
    
    uniform int N;
    uniform int itr;
    uniform vec2 d;
    uniform sampler2D ta;
    
    out vec4 fragColor;
    
    vec2 mul(vec2 a, vec2 b) {
        return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
    }
    
    vec2 expi(uint n) {
        float y  = +2.0*acos(-1.0)/float(itr)*float(n);
        return vec2(cos(y), sin(y));
    }
    
    void main() {
        uint n = uint(N);
        uint m = uint(itr);
        uvec2 pi = uvec2(gl_FragCoord.xy);
        uvec2 pim = pi&((m>>1)-1u);
        uvec2 pio = pi&~(m-1u)+pim;
    
        vec2 v0 = texture(ta, (vec2(pio+uvec2(0u,   0u  ))+0.5)*d).xy;
        vec2 v1 = texture(ta, (vec2(pio+uvec2(m>>1, 0u  ))+0.5)*d).xy;
        vec2 v2 = texture(ta, (vec2(pio+uvec2(0u,   m>>1))+0.5)*d).xy;
        vec2 v3 = texture(ta, (vec2(pio+uvec2(m>>1, m>>1))+0.5)*d).xy;
    
        //v0 = mul(v0, expi((0u       )%m));
        v1 = mul(v1, expi((pi.x     )&(m-1u)));
        v2 = mul(v2, expi((pi.y     )&(m-1u)));
        v3 = mul(v3, expi((pi.x+pi.y)&(m-1u)));
    
        vec2 res = v0+v1+v2+v3;
        fragColor = vec4(res, 0.0, 0.0);
}
</script>
<!-- }}} -->


<script lang="javascript">
    'use strict';

    // let N = 256;        // image size (width and height)
    let N = 512;        // image size (width and height)

    let renderer;       // WebGLRenderer
    let ctx      = [];  // canvas contexts
    let mfscv    = [];  // ShaderMaterial for canvas
    let mfs      = [];  // ShaderMaterial for texture
    let tex      = [];  // textures
    let texd     = [];  // textures for drawing
    let uniform  = [];


    // renderer
    let canvas = document.createElement('canvas');
    let context = canvas.getContext('webgl2', {alpha: false});
    renderer = new THREE.WebGLRenderer({canvas: canvas, context: context});
    renderer.setSize(N, N);

    // textures
    var options = {
        type: THREE.FloatType,
        magFilter: THREE.NearestFilter,
        minFilter: THREE.NearestFilter,
    };
    // tex[0]
    tex.push(new THREE.WebGLRenderTarget(N, N, options));
    // tex[1]
    tex.push([
        new THREE.WebGLRenderTarget(N, N, options),
        new THREE.WebGLRenderTarget(N, N, options),
    ]);
    // tex[2]
    tex.push(new THREE.WebGLRenderTarget(N, N, options));
    // tex[3]
    tex.push([
        new THREE.WebGLRenderTarget(N, N, options),
        new THREE.WebGLRenderTarget(N, N, options),
    ]);
    // texd
    texd.push([
        new THREE.WebGLRenderTarget(N, N, options),
        new THREE.WebGLRenderTarget(N, N, options),
    ]);

    // prepare shader materials
    for(let i=0;i<4;i++){
        uniform.push({
            N:          {type: 'i',  value: N},
            itr:        {type: 'i',  value: 1},
            d:          {type: 'v2', value: new THREE.Vector2(1.0/N, 1.0/N)},
            ta:         {type: 't',  value: undefined},
            tb:         {type: 't',  value: undefined},
        });
        mfscv.push(
            new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vs').textContent.trim(),
                fragmentShader: document.getElementById('fscv'+i).textContent.trim(),
                uniforms: uniform[i],
            })
        );
        mfs.push(
            new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vs').textContent.trim(),
                fragmentShader: document.getElementById('fs'+i).textContent.trim(),
                uniforms: uniform[i],
            })
        );
    }


    let scene    = new THREE.Scene();
    let camera   = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -1, 1);

    camera.position.z = 1;
    scene.add(camera)

    let plane = new THREE.PlaneGeometry(1.0, 1.0);
    let mesh  = new THREE.Mesh(plane);
    scene.add(mesh);

    var app = new Vue({
        el: '.app',
        data: {
            imageURL: 'image/lena.png',
        }, 
        mounted: function () {
            // prepare renderer
            for(let i=0;i<4;i++){
                let cv = document.getElementById('cv'+i);
                cv.width  = N;
                cv.height = N;
                // cv.style.width  = 512;
                // cv.style.height = 512;
                cv.style.width  = N;
                cv.style.height = N;
                ctx.push(cv.getContext('2d'));
            }

            this.loadImage();
        },
        methods: {
            loadImage: function() {
                var loader = new THREE.TextureLoader();
                loader.load(
                    this.imageURL,
                    // onLoad callback
                    this.init,
                    // onProgress callback currently not supported
                    undefined,
                    // onError callback
                    function() {
                        console.error('Load Error');
                    }
                );
            },
            init: function(texture) {
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                tex[0].texture = texture;

                // phase 0
                // render to tex[1][0];
                mesh.material = mfs[0];
                uniform[0].ta.value = tex[0].texture;
                renderer.setRenderTarget(tex[1][0]);
                renderer.render(scene, camera)

                // render to canvas
                mesh.material = mfscv[0];
                uniform[0].ta.value = tex[0].texture;
                renderer.setRenderTarget(null);
                renderer.render(scene, camera)
                ctx[0].drawImage(renderer.domElement, 0, 0);


                // phase 1
                // forward Fourier transform
                mesh.material = mfs[1];
                let ping = 0;
                for(let itr=2;itr<=N;itr*=2){ // TODO rename itr
                    uniform[1].ta.value = tex[1][ping].texture;
                    uniform[1].itr.value = itr;
                    renderer.setRenderTarget(tex[1][1-ping]);
                    renderer.render(scene, camera)
                    ping = 1-ping;
                }

                // render to canvas
                mesh.material = mfscv[1];
                uniform[1].ta.value = tex[1][ping].texture;
                renderer.setRenderTarget(null);
                renderer.render(scene, camera)
                ctx[1].drawImage(renderer.domElement, 0, 0);


                // phase 2
                // merge drawings
                mesh.material = mfs[2];
                uniform[2].ta.value = tex[1][ping].texture;
                renderer.setRenderTarget(tex[3][0]);
                renderer.render(scene, camera)

                // render to canvas
                mesh.material = mfscv[2];
                uniform[2].ta.value = tex[1][ping].texture;
                //uniform[2].ta.value = texd[ping].texture; // TODO
                renderer.setRenderTarget(null);
                renderer.render(scene, camera)
                ctx[2].drawImage(renderer.domElement, 0, 0);


                // phase 3
                // backward Fourier transform
                mesh.material = mfs[3];
                ping = 0;
                for(let itr=2;itr<=N;itr*=2){ // TODO rename itr
                    uniform[3].ta.value = tex[3][ping].texture;
                    uniform[3].itr.value = itr;
                    renderer.setRenderTarget(tex[3][1-ping]);
                    renderer.render(scene, camera)
                    ping = 1-ping;
                }

                // render to canvas
                mesh.material = mfscv[3];
                uniform[3].ta.value = tex[3][ping].texture;
                renderer.setRenderTarget(null);
                renderer.render(scene, camera)
                ctx[3].drawImage(renderer.domElement, 0, 0);
            },
        },
    });
</script>
